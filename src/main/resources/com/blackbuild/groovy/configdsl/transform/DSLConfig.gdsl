package com.blackbuild.groovy.configdsl.transform

import com.intellij.psi.PsiAnnotation
import com.intellij.psi.PsiClass
import com.intellij.psi.PsiClassType
import com.intellij.psi.PsiEllipsisType
import com.intellij.psi.PsiField
import com.intellij.psi.PsiType


contributor(ctype:hasAnnotation("com.blackbuild.groovy.configdsl.transform.DSLConfig")) {
    ClassConfig clazz = new ClassConfig(psiClass)
    method(
            name: "apply",
            doc: "Applies the configuration in the closure." as String,
            params: [closure: Closure.class.name],
            type: clazz.type.qualifiedName
    )

    if (clazz.key) {
        method(
                name: "create",
                doc: "Creates a new instance of ${clazz.type.qualifiedName} using 'key' as $clazz.key" as String,
                isStatic: true,
                params: ["$clazz.key": "java.lang.String", closure: Closure.class.name],
                type: clazz.type.qualifiedName
        )
        method(constructor: true, params: ["$clazz.key": "java.lang.String"])
    } else {
        method(
                name: "create",
                doc: "Creates a new instance of ${clazz.type.qualifiedName}" as String,
                isStatic: true,
                params: [closure: Closure.class.name],
                type: clazz.type.qualifiedName
        )
    }

    classType?.fields?.each { PsiField rawField ->

        def field = new FieldConfig(rawField)
        def fieldType = field.targetConfig

        if (fieldType) {
            if (!field.collectionOfDslObjects && fieldType.key)
                method(
                        name: field.name,
                        doc: "Sets the $field.name, using the key as $fieldType.key." as String,
                        params: ["$fieldType.key": "java.lang.String", value: 'Closure'],
                        type: 'void'
                )
            else
                method(
                        name: field.name,
                        doc: "Sets the $field.name" as String,
                        params: [value: 'Closure'],
                        type: 'void'
                )
        } else if (field.collectionOfDslObjects) {
            method(
                    name: field.name,
                    doc: "Enter $field.name via closure" as String,
                    params: [closure: Closure.class.name],
                    type: 'void'
            )
        } else {
            if (field.isList()) {
                //noinspection GroovyAssignabilityCheck
                method(
                        name: field.name,
                        doc: "Adds a number of ${field.elementType}s to $field.name list" as String,
                        params: [values: field.elementTypeAsVararg?.canonicalText],
                        type: 'void'
                )
                method(
                        name: field.element,
                        doc: "Adds a single ${field.elementType} to $field.name list" as String,
                        params: [value: field.elementType?.canonicalText],
                        type: 'void'
                )
            } else if (field.isMap()) {
                method(
                        name: field.name,
                        doc: "Adds a map of entries to $field.name list" as String,
                        params: [values: field.type?.canonicalText],
                        type: 'void'
                )
                method(
                        name: field.element,
                        doc: "Adds a single ${field.elementType} to $field.name map using key as the key." as String,
                        params: [key: field.keyType?.canonicalText, value: field.valueType?.canonicalText],
                        type: 'void'
                )
            } else {
                method(
                        name: field.name,
                        doc: "Sets the $field.name" as String,
                        params: [value: field.type?.canonicalText],
                        type: 'void'
                )
            }
        }
    }
}

contributor(context(scope: closureScope(), ctype:hasAnnotation("com.blackbuild.groovy.configdsl.transform.DSLConfig"))) {

    ClassConfig clazz = new ClassConfig(psiClass)

    def innerMostKnownClosureField = clazz.allDslCollectionFields.find{FieldConfig field -> enclosingCall(field.name) || enclosingCall(field.element)}

    if (innerMostKnownClosureField) {

        def elementType = innerMostKnownClosureField.targetConfig

        if (enclosingCall(innerMostKnownClosureField.element)) {
            delegatesTo(elementType.type)
        } else {
            method(
                    name: innerMostKnownClosureField.element,
                    doc: "Creates s single instance of $innerMostKnownClosureField.element and adds it." as String,
                    params: elementType.key ? ["$elementType.key": "java.lang.String", value: 'Closure'] : [value: 'Closure'],
                    type: 'void'
            )
            // TODO: alternatives
            method(
                    name: "_reuse",
                    doc: """Reuses an existing instance of $elementType.type.qualifiedName.
This will not affect the owner of the added object.""" as String,
                    params: [value: elementType.type.qualifiedName],
                    type: 'void'
            )
            method(
                    name: '_use',
                    doc: """Adds an existing instance of $elementType.type.qualifiedName.
The added objects must not have an owner yet.""" as String,
                    params: [value: elementType.type.qualifiedName],
                    type: 'void'
            )
        }
    }

    clazz.allSingleDSLFields.each { field ->

        def call = enclosingCall(field.name)
        if (call) {
            delegatesTo(field.type.resolve())
        }
    }
}

@SuppressWarnings("GroovyAssignabilityCheck")
class FieldConfig {
    String name
    boolean optional
    String element
    PsiField field

    ClassConfig targetConfig
    private PsiAnnotation fieldAnnotation

    boolean isDslObject

    FieldConfig(PsiField field) {
        this.field = field
        this.fieldAnnotation = field.getAnnotation("com.blackbuild.groovy.configdsl.transform.DSLField")
        name = this.fieldAnnotation?.findDeclaredAttributeValue("value")?.node?.text ?: field.name
        name = name.replace('"', '')
        optional = this.fieldAnnotation?.findDeclaredAttributeValue("optional")?.node?.text ?: false
        element = this.fieldAnnotation?.findDeclaredAttributeValue("element")?.node?.text?.replace('"', '')

        if (!element)
            element = name.endsWith('s') ? name[0..-2] : name

        ClassConfig config = new ClassConfig(field.classType)
        if (config.dslClass) {
            targetConfig = config
            isDslObject = true
        }
        else if (isCollectionOfDslObjects())
            targetConfig = new ClassConfig(elementType.resolve())
    }

    PsiType getType() {
        field.type
    }

    PsiClassType getElementType() {

        isList() ? field.type.parameters[0] as PsiType : isMap() ? getValueType() : null
    }

    PsiType getKeyType() {
        field.type.parameters[0] as PsiType
    }

    PsiType getValueType() {
        field.type.parameters.length > 1 ? field.type.parameters[1] as PsiType : null
    }

    PsiEllipsisType getElementTypeAsVararg() {
        new PsiEllipsisType(elementType)
    }

    boolean isOfType(String typeString) {
        field.type instanceof PsiClassType && (field.type.resolve()?.qualifiedName == typeString || field.type.resolve()?.supers?.find { it.qualifiedName == typeString })
    }

    boolean isList() {
        isOfType "java.util.List"
    }

    boolean isMap() {
        isOfType "java.util.Map"
    }

    boolean isCollectionOfDslObjects() {
        elementType?.resolve()?.getAnnotation("com.blackbuild.groovy.configdsl.transform.DSLConfig")
    }

    List<PsiClass> getAlternatives() {
        this.fieldAnnotation?.findAttributeValue("alternatives")
        // TODO implement
    }

    @Override
    String toString() {
        return "Field: $field.name ($type.canonicalText) [$targetConfig]"
    }
}

class ClassConfig {
    String key
    PsiClass type
    boolean dslClass

    ClassConfig(PsiClass type) {
        this.type = type

        def dslAnnotation = type?.getAnnotation("com.blackbuild.groovy.configdsl.transform.DSLConfig")
        key = dslAnnotation?.findDeclaredAttributeValue("key")?.node?.text?.replace('"', '')

        dslClass = dslAnnotation != null
    }

    Set<FieldConfig> getAllDslCollectionFields() {
        def ownFields = type.fields.collect { PsiField field -> new FieldConfig(field)}.findAll{FieldConfig f -> f.collectionOfDslObjects }

        def result = ownFields.collect()

        ownFields.each { FieldConfig f ->
            result.addAll(0, f.targetConfig.allDslCollectionFields)
        }

        return result as Set
    }

    Set<FieldConfig> getAllSingleDSLFields() {
        return type.fields.collect { PsiField field -> new FieldConfig(field)}.findAll{FieldConfig f -> f.isDslObject } as Set
    }

    @Override
    String toString() {
        return "DSLClass: $type.qualifiedName"
    }

}
